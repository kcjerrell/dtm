// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SAMPLER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SAMPLER_TYPE: i8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SAMPLER_TYPE: [SamplerType; 19] = [
  SamplerType::DPMPP2MKarras,
  SamplerType::EulerA,
  SamplerType::DDIM,
  SamplerType::PLMS,
  SamplerType::DPMPPSDEKarras,
  SamplerType::UniPC,
  SamplerType::LCM,
  SamplerType::EulerASubstep,
  SamplerType::DPMPPSDESubstep,
  SamplerType::TCD,
  SamplerType::EulerATrailing,
  SamplerType::DPMPPSDETrailing,
  SamplerType::DPMPP2MAYS,
  SamplerType::EulerAAYS,
  SamplerType::DPMPPSDEAYS,
  SamplerType::DPMPP2MTrailing,
  SamplerType::DDIMTrailing,
  SamplerType::UniPCTrailing,
  SamplerType::UniPCAYS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SamplerType(pub i8);
#[allow(non_upper_case_globals)]
impl SamplerType {
  pub const DPMPP2MKarras: Self = Self(0);
  pub const EulerA: Self = Self(1);
  pub const DDIM: Self = Self(2);
  pub const PLMS: Self = Self(3);
  pub const DPMPPSDEKarras: Self = Self(4);
  pub const UniPC: Self = Self(5);
  pub const LCM: Self = Self(6);
  pub const EulerASubstep: Self = Self(7);
  pub const DPMPPSDESubstep: Self = Self(8);
  pub const TCD: Self = Self(9);
  pub const EulerATrailing: Self = Self(10);
  pub const DPMPPSDETrailing: Self = Self(11);
  pub const DPMPP2MAYS: Self = Self(12);
  pub const EulerAAYS: Self = Self(13);
  pub const DPMPPSDEAYS: Self = Self(14);
  pub const DPMPP2MTrailing: Self = Self(15);
  pub const DDIMTrailing: Self = Self(16);
  pub const UniPCTrailing: Self = Self(17);
  pub const UniPCAYS: Self = Self(18);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DPMPP2MKarras,
    Self::EulerA,
    Self::DDIM,
    Self::PLMS,
    Self::DPMPPSDEKarras,
    Self::UniPC,
    Self::LCM,
    Self::EulerASubstep,
    Self::DPMPPSDESubstep,
    Self::TCD,
    Self::EulerATrailing,
    Self::DPMPPSDETrailing,
    Self::DPMPP2MAYS,
    Self::EulerAAYS,
    Self::DPMPPSDEAYS,
    Self::DPMPP2MTrailing,
    Self::DDIMTrailing,
    Self::UniPCTrailing,
    Self::UniPCAYS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DPMPP2MKarras => Some("DPMPP2MKarras"),
      Self::EulerA => Some("EulerA"),
      Self::DDIM => Some("DDIM"),
      Self::PLMS => Some("PLMS"),
      Self::DPMPPSDEKarras => Some("DPMPPSDEKarras"),
      Self::UniPC => Some("UniPC"),
      Self::LCM => Some("LCM"),
      Self::EulerASubstep => Some("EulerASubstep"),
      Self::DPMPPSDESubstep => Some("DPMPPSDESubstep"),
      Self::TCD => Some("TCD"),
      Self::EulerATrailing => Some("EulerATrailing"),
      Self::DPMPPSDETrailing => Some("DPMPPSDETrailing"),
      Self::DPMPP2MAYS => Some("DPMPP2MAYS"),
      Self::EulerAAYS => Some("EulerAAYS"),
      Self::DPMPPSDEAYS => Some("DPMPPSDEAYS"),
      Self::DPMPP2MTrailing => Some("DPMPP2MTrailing"),
      Self::DDIMTrailing => Some("DDIMTrailing"),
      Self::UniPCTrailing => Some("UniPCTrailing"),
      Self::UniPCAYS => Some("UniPCAYS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SamplerType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SamplerType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SamplerType {
    type Output = SamplerType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SamplerType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SamplerType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SamplerType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEED_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEED_MODE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEED_MODE: [SeedMode; 4] = [
  SeedMode::Legacy,
  SeedMode::TorchCpuCompatible,
  SeedMode::ScaleAlike,
  SeedMode::NvidiaGpuCompatible,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SeedMode(pub i8);
#[allow(non_upper_case_globals)]
impl SeedMode {
  pub const Legacy: Self = Self(0);
  pub const TorchCpuCompatible: Self = Self(1);
  pub const ScaleAlike: Self = Self(2);
  pub const NvidiaGpuCompatible: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Legacy,
    Self::TorchCpuCompatible,
    Self::ScaleAlike,
    Self::NvidiaGpuCompatible,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Legacy => Some("Legacy"),
      Self::TorchCpuCompatible => Some("TorchCpuCompatible"),
      Self::ScaleAlike => Some("ScaleAlike"),
      Self::NvidiaGpuCompatible => Some("NvidiaGpuCompatible"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SeedMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SeedMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SeedMode {
    type Output = SeedMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SeedMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SeedMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SeedMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTROL_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTROL_MODE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTROL_MODE: [ControlMode; 3] = [
  ControlMode::Balanced,
  ControlMode::Prompt,
  ControlMode::Control,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ControlMode(pub i8);
#[allow(non_upper_case_globals)]
impl ControlMode {
  pub const Balanced: Self = Self(0);
  pub const Prompt: Self = Self(1);
  pub const Control: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Balanced,
    Self::Prompt,
    Self::Control,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Balanced => Some("Balanced"),
      Self::Prompt => Some("Prompt"),
      Self::Control => Some("Control"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ControlMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ControlMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ControlMode {
    type Output = ControlMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ControlMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ControlMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ControlMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTROL_INPUT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTROL_INPUT_TYPE: i8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTROL_INPUT_TYPE: [ControlInputType; 19] = [
  ControlInputType::Unspecified,
  ControlInputType::Custom,
  ControlInputType::Depth,
  ControlInputType::Canny,
  ControlInputType::Scribble,
  ControlInputType::Pose,
  ControlInputType::Normalbae,
  ControlInputType::Color,
  ControlInputType::Lineart,
  ControlInputType::Softedge,
  ControlInputType::Seg,
  ControlInputType::Inpaint,
  ControlInputType::Ip2p,
  ControlInputType::Shuffle,
  ControlInputType::Mlsd,
  ControlInputType::Tile,
  ControlInputType::Blur,
  ControlInputType::Lowquality,
  ControlInputType::Gray,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ControlInputType(pub i8);
#[allow(non_upper_case_globals)]
impl ControlInputType {
  pub const Unspecified: Self = Self(0);
  pub const Custom: Self = Self(1);
  pub const Depth: Self = Self(2);
  pub const Canny: Self = Self(3);
  pub const Scribble: Self = Self(4);
  pub const Pose: Self = Self(5);
  pub const Normalbae: Self = Self(6);
  pub const Color: Self = Self(7);
  pub const Lineart: Self = Self(8);
  pub const Softedge: Self = Self(9);
  pub const Seg: Self = Self(10);
  pub const Inpaint: Self = Self(11);
  pub const Ip2p: Self = Self(12);
  pub const Shuffle: Self = Self(13);
  pub const Mlsd: Self = Self(14);
  pub const Tile: Self = Self(15);
  pub const Blur: Self = Self(16);
  pub const Lowquality: Self = Self(17);
  pub const Gray: Self = Self(18);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unspecified,
    Self::Custom,
    Self::Depth,
    Self::Canny,
    Self::Scribble,
    Self::Pose,
    Self::Normalbae,
    Self::Color,
    Self::Lineart,
    Self::Softedge,
    Self::Seg,
    Self::Inpaint,
    Self::Ip2p,
    Self::Shuffle,
    Self::Mlsd,
    Self::Tile,
    Self::Blur,
    Self::Lowquality,
    Self::Gray,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unspecified => Some("Unspecified"),
      Self::Custom => Some("Custom"),
      Self::Depth => Some("Depth"),
      Self::Canny => Some("Canny"),
      Self::Scribble => Some("Scribble"),
      Self::Pose => Some("Pose"),
      Self::Normalbae => Some("Normalbae"),
      Self::Color => Some("Color"),
      Self::Lineart => Some("Lineart"),
      Self::Softedge => Some("Softedge"),
      Self::Seg => Some("Seg"),
      Self::Inpaint => Some("Inpaint"),
      Self::Ip2p => Some("Ip2p"),
      Self::Shuffle => Some("Shuffle"),
      Self::Mlsd => Some("Mlsd"),
      Self::Tile => Some("Tile"),
      Self::Blur => Some("Blur"),
      Self::Lowquality => Some("Lowquality"),
      Self::Gray => Some("Gray"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ControlInputType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ControlInputType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ControlInputType {
    type Output = ControlInputType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ControlInputType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ControlInputType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ControlInputType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LO_RAMODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LO_RAMODE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LO_RAMODE: [LoRAMode; 3] = [
  LoRAMode::All,
  LoRAMode::Base,
  LoRAMode::Refiner,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LoRAMode(pub i8);
#[allow(non_upper_case_globals)]
impl LoRAMode {
  pub const All: Self = Self(0);
  pub const Base: Self = Self(1);
  pub const Refiner: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::All,
    Self::Base,
    Self::Refiner,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::All => Some("All"),
      Self::Base => Some("Base"),
      Self::Refiner => Some("Refiner"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LoRAMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LoRAMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LoRAMode {
    type Output = LoRAMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LoRAMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LoRAMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LoRAMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REASON: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REASON: i32 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REASON: [Reason; 9] = [
  Reason::Other,
  Reason::Generate,
  Reason::Imported,
  Reason::Draw,
  Reason::Mask,
  Reason::Scribble,
  Reason::Moodboard,
  Reason::DepthMap,
  Reason::Clear,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Reason(pub i32);
#[allow(non_upper_case_globals)]
impl Reason {
  pub const Other: Self = Self(0);
  pub const Generate: Self = Self(1);
  pub const Imported: Self = Self(2);
  pub const Draw: Self = Self(3);
  pub const Mask: Self = Self(4);
  pub const Scribble: Self = Self(5);
  pub const Moodboard: Self = Self(6);
  pub const DepthMap: Self = Self(7);
  pub const Clear: Self = Self(8);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Other,
    Self::Generate,
    Self::Imported,
    Self::Draw,
    Self::Mask,
    Self::Scribble,
    Self::Moodboard,
    Self::DepthMap,
    Self::Clear,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Other => Some("Other"),
      Self::Generate => Some("Generate"),
      Self::Imported => Some("Imported"),
      Self::Draw => Some("Draw"),
      Self::Mask => Some("Mask"),
      Self::Scribble => Some("Scribble"),
      Self::Moodboard => Some("Moodboard"),
      Self::DepthMap => Some("DepthMap"),
      Self::Clear => Some("Clear"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Reason {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Reason {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Reason {
    type Output = Reason;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Reason {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Reason {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Reason {}
pub enum ControlOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Control<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Control<'a> {
  type Inner = Control<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Control<'a> {
  pub const VT_FILE: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_GUIDANCE_START: flatbuffers::VOffsetT = 8;
  pub const VT_GUIDANCE_END: flatbuffers::VOffsetT = 10;
  pub const VT_NO_PROMPT: flatbuffers::VOffsetT = 12;
  pub const VT_GLOBAL_AVERAGE_POOLING: flatbuffers::VOffsetT = 14;
  pub const VT_DOWN_SAMPLING_RATE: flatbuffers::VOffsetT = 16;
  pub const VT_CONTROL_MODE: flatbuffers::VOffsetT = 18;
  pub const VT_TARGET_BLOCKS: flatbuffers::VOffsetT = 20;
  pub const VT_INPUT_OVERRIDE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Control { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ControlArgs<'args>
  ) -> flatbuffers::WIPOffset<Control<'bldr>> {
    let mut builder = ControlBuilder::new(_fbb);
    if let Some(x) = args.target_blocks { builder.add_target_blocks(x); }
    builder.add_down_sampling_rate(args.down_sampling_rate);
    builder.add_guidance_end(args.guidance_end);
    builder.add_guidance_start(args.guidance_start);
    builder.add_weight(args.weight);
    if let Some(x) = args.file { builder.add_file(x); }
    builder.add_input_override(args.input_override);
    builder.add_control_mode(args.control_mode);
    builder.add_global_average_pooling(args.global_average_pooling);
    builder.add_no_prompt(args.no_prompt);
    builder.finish()
  }


  #[inline]
  pub fn file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Control::VT_FILE, None)}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_WEIGHT, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn guidance_start(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_GUIDANCE_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn guidance_end(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_GUIDANCE_END, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn no_prompt(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Control::VT_NO_PROMPT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn global_average_pooling(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Control::VT_GLOBAL_AVERAGE_POOLING, Some(true)).unwrap()}
  }
  #[inline]
  pub fn down_sampling_rate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_DOWN_SAMPLING_RATE, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn control_mode(&self) -> ControlMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ControlMode>(Control::VT_CONTROL_MODE, Some(ControlMode::Balanced)).unwrap()}
  }
  #[inline]
  pub fn target_blocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Control::VT_TARGET_BLOCKS, None)}
  }
  #[inline]
  pub fn input_override(&self) -> ControlInputType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ControlInputType>(Control::VT_INPUT_OVERRIDE, Some(ControlInputType::Unspecified)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Control<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file", Self::VT_FILE, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<f32>("guidance_start", Self::VT_GUIDANCE_START, false)?
     .visit_field::<f32>("guidance_end", Self::VT_GUIDANCE_END, false)?
     .visit_field::<bool>("no_prompt", Self::VT_NO_PROMPT, false)?
     .visit_field::<bool>("global_average_pooling", Self::VT_GLOBAL_AVERAGE_POOLING, false)?
     .visit_field::<f32>("down_sampling_rate", Self::VT_DOWN_SAMPLING_RATE, false)?
     .visit_field::<ControlMode>("control_mode", Self::VT_CONTROL_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("target_blocks", Self::VT_TARGET_BLOCKS, false)?
     .visit_field::<ControlInputType>("input_override", Self::VT_INPUT_OVERRIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct ControlArgs<'a> {
    pub file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub guidance_start: f32,
    pub guidance_end: f32,
    pub no_prompt: bool,
    pub global_average_pooling: bool,
    pub down_sampling_rate: f32,
    pub control_mode: ControlMode,
    pub target_blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub input_override: ControlInputType,
}
impl<'a> Default for ControlArgs<'a> {
  #[inline]
  fn default() -> Self {
    ControlArgs {
      file: None,
      weight: 1.0,
      guidance_start: 0.0,
      guidance_end: 1.0,
      no_prompt: false,
      global_average_pooling: true,
      down_sampling_rate: 1.0,
      control_mode: ControlMode::Balanced,
      target_blocks: None,
      input_override: ControlInputType::Unspecified,
    }
  }
}

pub struct ControlBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControlBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Control::VT_FILE, file);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_WEIGHT, weight, 1.0);
  }
  #[inline]
  pub fn add_guidance_start(&mut self, guidance_start: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_GUIDANCE_START, guidance_start, 0.0);
  }
  #[inline]
  pub fn add_guidance_end(&mut self, guidance_end: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_GUIDANCE_END, guidance_end, 1.0);
  }
  #[inline]
  pub fn add_no_prompt(&mut self, no_prompt: bool) {
    self.fbb_.push_slot::<bool>(Control::VT_NO_PROMPT, no_prompt, false);
  }
  #[inline]
  pub fn add_global_average_pooling(&mut self, global_average_pooling: bool) {
    self.fbb_.push_slot::<bool>(Control::VT_GLOBAL_AVERAGE_POOLING, global_average_pooling, true);
  }
  #[inline]
  pub fn add_down_sampling_rate(&mut self, down_sampling_rate: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_DOWN_SAMPLING_RATE, down_sampling_rate, 1.0);
  }
  #[inline]
  pub fn add_control_mode(&mut self, control_mode: ControlMode) {
    self.fbb_.push_slot::<ControlMode>(Control::VT_CONTROL_MODE, control_mode, ControlMode::Balanced);
  }
  #[inline]
  pub fn add_target_blocks(&mut self, target_blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Control::VT_TARGET_BLOCKS, target_blocks);
  }
  #[inline]
  pub fn add_input_override(&mut self, input_override: ControlInputType) {
    self.fbb_.push_slot::<ControlInputType>(Control::VT_INPUT_OVERRIDE, input_override, ControlInputType::Unspecified);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ControlBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ControlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Control<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Control<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Control");
      ds.field("file", &self.file());
      ds.field("weight", &self.weight());
      ds.field("guidance_start", &self.guidance_start());
      ds.field("guidance_end", &self.guidance_end());
      ds.field("no_prompt", &self.no_prompt());
      ds.field("global_average_pooling", &self.global_average_pooling());
      ds.field("down_sampling_rate", &self.down_sampling_rate());
      ds.field("control_mode", &self.control_mode());
      ds.field("target_blocks", &self.target_blocks());
      ds.field("input_override", &self.input_override());
      ds.finish()
  }
}
pub enum LoRAOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoRA<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoRA<'a> {
  type Inner = LoRA<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoRA<'a> {
  pub const VT_FILE: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_MODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoRA { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoRAArgs<'args>
  ) -> flatbuffers::WIPOffset<LoRA<'bldr>> {
    let mut builder = LoRABuilder::new(_fbb);
    builder.add_weight(args.weight);
    if let Some(x) = args.file { builder.add_file(x); }
    builder.add_mode(args.mode);
    builder.finish()
  }


  #[inline]
  pub fn file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoRA::VT_FILE, None)}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LoRA::VT_WEIGHT, Some(0.6)).unwrap()}
  }
  #[inline]
  pub fn mode(&self) -> LoRAMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LoRAMode>(LoRA::VT_MODE, Some(LoRAMode::All)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoRA<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file", Self::VT_FILE, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<LoRAMode>("mode", Self::VT_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct LoRAArgs<'a> {
    pub file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub mode: LoRAMode,
}
impl<'a> Default for LoRAArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoRAArgs {
      file: None,
      weight: 0.6,
      mode: LoRAMode::All,
    }
  }
}

pub struct LoRABuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoRABuilder<'a, 'b, A> {
  #[inline]
  pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoRA::VT_FILE, file);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(LoRA::VT_WEIGHT, weight, 0.6);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: LoRAMode) {
    self.fbb_.push_slot::<LoRAMode>(LoRA::VT_MODE, mode, LoRAMode::All);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoRABuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoRABuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoRA<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoRA<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoRA");
      ds.field("file", &self.file());
      ds.field("weight", &self.weight());
      ds.field("mode", &self.mode());
      ds.finish()
  }
}
pub enum TensorHistoryNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorHistoryNode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorHistoryNode<'a> {
  type Inner = TensorHistoryNode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorHistoryNode<'a> {
  pub const VT_LINEAGE: flatbuffers::VOffsetT = 4;
  pub const VT_LOGICAL_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_START_WIDTH: flatbuffers::VOffsetT = 8;
  pub const VT_START_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_SEED: flatbuffers::VOffsetT = 12;
  pub const VT_STEPS: flatbuffers::VOffsetT = 14;
  pub const VT_GUIDANCE_SCALE: flatbuffers::VOffsetT = 16;
  pub const VT_STRENGTH: flatbuffers::VOffsetT = 18;
  pub const VT_MODEL: flatbuffers::VOffsetT = 20;
  pub const VT_TENSOR_ID: flatbuffers::VOffsetT = 22;
  pub const VT_MASK_ID: flatbuffers::VOffsetT = 24;
  pub const VT_WALL_CLOCK: flatbuffers::VOffsetT = 26;
  pub const VT_TEXT_EDITS: flatbuffers::VOffsetT = 28;
  pub const VT_TEXT_LINEAGE: flatbuffers::VOffsetT = 30;
  pub const VT_BATCH_SIZE: flatbuffers::VOffsetT = 32;
  pub const VT_SAMPLER: flatbuffers::VOffsetT = 34;
  pub const VT_HIRES_FIX: flatbuffers::VOffsetT = 36;
  pub const VT_HIRES_FIX_START_WIDTH: flatbuffers::VOffsetT = 38;
  pub const VT_HIRES_FIX_START_HEIGHT: flatbuffers::VOffsetT = 40;
  pub const VT_HIRES_FIX_STRENGTH: flatbuffers::VOffsetT = 42;
  pub const VT_UPSCALER: flatbuffers::VOffsetT = 44;
  pub const VT_SCALE_FACTOR: flatbuffers::VOffsetT = 46;
  pub const VT_DEPTH_MAP_ID: flatbuffers::VOffsetT = 48;
  pub const VT_GENERATED: flatbuffers::VOffsetT = 50;
  pub const VT_IMAGE_GUIDANCE_SCALE: flatbuffers::VOffsetT = 52;
  pub const VT_SEED_MODE: flatbuffers::VOffsetT = 54;
  pub const VT_CLIP_SKIP: flatbuffers::VOffsetT = 56;
  pub const VT_CONTROLS: flatbuffers::VOffsetT = 58;
  pub const VT_SCRIBBLE_ID: flatbuffers::VOffsetT = 60;
  pub const VT_POSE_ID: flatbuffers::VOffsetT = 62;
  pub const VT_LORAS: flatbuffers::VOffsetT = 64;
  pub const VT_COLOR_PALETTE_ID: flatbuffers::VOffsetT = 66;
  pub const VT_MASK_BLUR: flatbuffers::VOffsetT = 68;
  pub const VT_CUSTOM_ID: flatbuffers::VOffsetT = 70;
  pub const VT_FACE_RESTORATION: flatbuffers::VOffsetT = 72;
  pub const VT_CLIP_WEIGHT: flatbuffers::VOffsetT = 78;
  pub const VT_NEGATIVE_PROMPT_FOR_IMAGE_PRIOR: flatbuffers::VOffsetT = 80;
  pub const VT_IMAGE_PRIOR_STEPS: flatbuffers::VOffsetT = 82;
  pub const VT_DATA_STORED: flatbuffers::VOffsetT = 84;
  pub const VT_PREVIEW_ID: flatbuffers::VOffsetT = 86;
  pub const VT_CONTENT_OFFSET_X: flatbuffers::VOffsetT = 88;
  pub const VT_CONTENT_OFFSET_Y: flatbuffers::VOffsetT = 90;
  pub const VT_SCALE_FACTOR_BY_120: flatbuffers::VOffsetT = 92;
  pub const VT_REFINER_MODEL: flatbuffers::VOffsetT = 94;
  pub const VT_ORIGINAL_IMAGE_HEIGHT: flatbuffers::VOffsetT = 96;
  pub const VT_ORIGINAL_IMAGE_WIDTH: flatbuffers::VOffsetT = 98;
  pub const VT_CROP_TOP: flatbuffers::VOffsetT = 100;
  pub const VT_CROP_LEFT: flatbuffers::VOffsetT = 102;
  pub const VT_TARGET_IMAGE_HEIGHT: flatbuffers::VOffsetT = 104;
  pub const VT_TARGET_IMAGE_WIDTH: flatbuffers::VOffsetT = 106;
  pub const VT_AESTHETIC_SCORE: flatbuffers::VOffsetT = 108;
  pub const VT_NEGATIVE_AESTHETIC_SCORE: flatbuffers::VOffsetT = 110;
  pub const VT_ZERO_NEGATIVE_PROMPT: flatbuffers::VOffsetT = 112;
  pub const VT_REFINER_START: flatbuffers::VOffsetT = 114;
  pub const VT_NEGATIVE_ORIGINAL_IMAGE_HEIGHT: flatbuffers::VOffsetT = 116;
  pub const VT_NEGATIVE_ORIGINAL_IMAGE_WIDTH: flatbuffers::VOffsetT = 118;
  pub const VT_SHUFFLE_DATA_STORED: flatbuffers::VOffsetT = 120;
  pub const VT_FPS_ID: flatbuffers::VOffsetT = 122;
  pub const VT_MOTION_BUCKET_ID: flatbuffers::VOffsetT = 124;
  pub const VT_COND_AUG: flatbuffers::VOffsetT = 126;
  pub const VT_START_FRAME_CFG: flatbuffers::VOffsetT = 128;
  pub const VT_NUM_FRAMES: flatbuffers::VOffsetT = 130;
  pub const VT_MASK_BLUR_OUTSET: flatbuffers::VOffsetT = 132;
  pub const VT_SHARPNESS: flatbuffers::VOffsetT = 134;
  pub const VT_SHIFT: flatbuffers::VOffsetT = 136;
  pub const VT_STAGE_2_STEPS: flatbuffers::VOffsetT = 138;
  pub const VT_STAGE_2_CFG: flatbuffers::VOffsetT = 140;
  pub const VT_STAGE_2_SHIFT: flatbuffers::VOffsetT = 142;
  pub const VT_TILED_DECODING: flatbuffers::VOffsetT = 144;
  pub const VT_DECODING_TILE_WIDTH: flatbuffers::VOffsetT = 146;
  pub const VT_DECODING_TILE_HEIGHT: flatbuffers::VOffsetT = 148;
  pub const VT_DECODING_TILE_OVERLAP: flatbuffers::VOffsetT = 150;
  pub const VT_STOCHASTIC_SAMPLING_GAMMA: flatbuffers::VOffsetT = 152;
  pub const VT_PRESERVE_ORIGINAL_AFTER_INPAINT: flatbuffers::VOffsetT = 154;
  pub const VT_TILED_DIFFUSION: flatbuffers::VOffsetT = 156;
  pub const VT_DIFFUSION_TILE_WIDTH: flatbuffers::VOffsetT = 158;
  pub const VT_DIFFUSION_TILE_HEIGHT: flatbuffers::VOffsetT = 160;
  pub const VT_DIFFUSION_TILE_OVERLAP: flatbuffers::VOffsetT = 162;
  pub const VT_UPSCALER_SCALE_FACTOR: flatbuffers::VOffsetT = 164;
  pub const VT_SCRIPT_SESSION_ID: flatbuffers::VOffsetT = 166;
  pub const VT_T5_TEXT_ENCODER: flatbuffers::VOffsetT = 168;
  pub const VT_SEPARATE_CLIP_L: flatbuffers::VOffsetT = 170;
  pub const VT_CLIP_L_TEXT: flatbuffers::VOffsetT = 172;
  pub const VT_SEPARATE_OPEN_CLIP_G: flatbuffers::VOffsetT = 174;
  pub const VT_OPEN_CLIP_G_TEXT: flatbuffers::VOffsetT = 176;
  pub const VT_SPEED_UP_WITH_GUIDANCE_EMBED: flatbuffers::VOffsetT = 178;
  pub const VT_GUIDANCE_EMBED: flatbuffers::VOffsetT = 180;
  pub const VT_RESOLUTION_DEPENDENT_SHIFT: flatbuffers::VOffsetT = 182;
  pub const VT_PROFILE_DATA: flatbuffers::VOffsetT = 184;
  pub const VT_TEA_CACHE_START: flatbuffers::VOffsetT = 186;
  pub const VT_TEA_CACHE_END: flatbuffers::VOffsetT = 188;
  pub const VT_TEA_CACHE_THRESHOLD: flatbuffers::VOffsetT = 190;
  pub const VT_TEA_CACHE: flatbuffers::VOffsetT = 192;
  pub const VT_SEPARATE_T5: flatbuffers::VOffsetT = 194;
  pub const VT_T5_TEXT: flatbuffers::VOffsetT = 196;
  pub const VT_TEA_CACHE_MAX_SKIP_STEPS: flatbuffers::VOffsetT = 198;
  pub const VT_TEXT_PROMPT: flatbuffers::VOffsetT = 200;
  pub const VT_NEGATIVE_TEXT_PROMPT: flatbuffers::VOffsetT = 202;
  pub const VT_CLIP_ID: flatbuffers::VOffsetT = 204;
  pub const VT_INDEX_IN_A_CLIP: flatbuffers::VOffsetT = 206;
  pub const VT_CAUSAL_INFERENCE_ENABLED: flatbuffers::VOffsetT = 208;
  pub const VT_CAUSAL_INFERENCE: flatbuffers::VOffsetT = 210;
  pub const VT_CAUSAL_INFERENCE_PAD: flatbuffers::VOffsetT = 212;
  pub const VT_CFG_ZERO_STAR: flatbuffers::VOffsetT = 214;
  pub const VT_CFG_ZERO_INIT_STEPS: flatbuffers::VOffsetT = 216;
  pub const VT_GENERATION_TIME: flatbuffers::VOffsetT = 218;
  pub const VT_REASON: flatbuffers::VOffsetT = 220;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorHistoryNode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorHistoryNodeArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorHistoryNode<'bldr>> {
    let mut builder = TensorHistoryNodeBuilder::new(_fbb);
    builder.add_generation_time(args.generation_time);
    builder.add_clip_id(args.clip_id);
    builder.add_script_session_id(args.script_session_id);
    builder.add_preview_id(args.preview_id);
    builder.add_custom_id(args.custom_id);
    builder.add_color_palette_id(args.color_palette_id);
    builder.add_pose_id(args.pose_id);
    builder.add_scribble_id(args.scribble_id);
    builder.add_depth_map_id(args.depth_map_id);
    builder.add_text_lineage(args.text_lineage);
    builder.add_text_edits(args.text_edits);
    builder.add_wall_clock(args.wall_clock);
    builder.add_mask_id(args.mask_id);
    builder.add_tensor_id(args.tensor_id);
    builder.add_logical_time(args.logical_time);
    builder.add_lineage(args.lineage);
    builder.add_reason(args.reason);
    builder.add_cfg_zero_init_steps(args.cfg_zero_init_steps);
    builder.add_causal_inference_pad(args.causal_inference_pad);
    builder.add_causal_inference(args.causal_inference);
    builder.add_index_in_a_clip(args.index_in_a_clip);
    if let Some(x) = args.negative_text_prompt { builder.add_negative_text_prompt(x); }
    if let Some(x) = args.text_prompt { builder.add_text_prompt(x); }
    builder.add_tea_cache_max_skip_steps(args.tea_cache_max_skip_steps);
    if let Some(x) = args.t5_text { builder.add_t5_text(x); }
    builder.add_tea_cache_threshold(args.tea_cache_threshold);
    builder.add_tea_cache_end(args.tea_cache_end);
    builder.add_tea_cache_start(args.tea_cache_start);
    if let Some(x) = args.profile_data { builder.add_profile_data(x); }
    builder.add_guidance_embed(args.guidance_embed);
    if let Some(x) = args.open_clip_g_text { builder.add_open_clip_g_text(x); }
    if let Some(x) = args.clip_l_text { builder.add_clip_l_text(x); }
    builder.add_stochastic_sampling_gamma(args.stochastic_sampling_gamma);
    builder.add_stage_2_shift(args.stage_2_shift);
    builder.add_stage_2_cfg(args.stage_2_cfg);
    builder.add_stage_2_steps(args.stage_2_steps);
    builder.add_shift(args.shift);
    builder.add_sharpness(args.sharpness);
    builder.add_mask_blur_outset(args.mask_blur_outset);
    builder.add_num_frames(args.num_frames);
    builder.add_start_frame_cfg(args.start_frame_cfg);
    builder.add_cond_aug(args.cond_aug);
    builder.add_motion_bucket_id(args.motion_bucket_id);
    builder.add_fps_id(args.fps_id);
    builder.add_shuffle_data_stored(args.shuffle_data_stored);
    builder.add_negative_original_image_width(args.negative_original_image_width);
    builder.add_negative_original_image_height(args.negative_original_image_height);
    builder.add_refiner_start(args.refiner_start);
    builder.add_negative_aesthetic_score(args.negative_aesthetic_score);
    builder.add_aesthetic_score(args.aesthetic_score);
    builder.add_target_image_width(args.target_image_width);
    builder.add_target_image_height(args.target_image_height);
    builder.add_crop_left(args.crop_left);
    builder.add_crop_top(args.crop_top);
    builder.add_original_image_width(args.original_image_width);
    builder.add_original_image_height(args.original_image_height);
    if let Some(x) = args.refiner_model { builder.add_refiner_model(x); }
    builder.add_scale_factor_by_120(args.scale_factor_by_120);
    builder.add_content_offset_y(args.content_offset_y);
    builder.add_content_offset_x(args.content_offset_x);
    builder.add_data_stored(args.data_stored);
    builder.add_image_prior_steps(args.image_prior_steps);
    builder.add_clip_weight(args.clip_weight);
    if let Some(x) = args.face_restoration { builder.add_face_restoration(x); }
    builder.add_mask_blur(args.mask_blur);
    if let Some(x) = args.loras { builder.add_loras(x); }
    if let Some(x) = args.controls { builder.add_controls(x); }
    builder.add_clip_skip(args.clip_skip);
    builder.add_image_guidance_scale(args.image_guidance_scale);
    if let Some(x) = args.upscaler { builder.add_upscaler(x); }
    builder.add_hires_fix_strength(args.hires_fix_strength);
    builder.add_batch_size(args.batch_size);
    if let Some(x) = args.model { builder.add_model(x); }
    builder.add_strength(args.strength);
    builder.add_guidance_scale(args.guidance_scale);
    builder.add_steps(args.steps);
    builder.add_seed(args.seed);
    builder.add_diffusion_tile_overlap(args.diffusion_tile_overlap);
    builder.add_diffusion_tile_height(args.diffusion_tile_height);
    builder.add_diffusion_tile_width(args.diffusion_tile_width);
    builder.add_decoding_tile_overlap(args.decoding_tile_overlap);
    builder.add_decoding_tile_height(args.decoding_tile_height);
    builder.add_decoding_tile_width(args.decoding_tile_width);
    builder.add_scale_factor(args.scale_factor);
    builder.add_hires_fix_start_height(args.hires_fix_start_height);
    builder.add_hires_fix_start_width(args.hires_fix_start_width);
    builder.add_start_height(args.start_height);
    builder.add_start_width(args.start_width);
    builder.add_cfg_zero_star(args.cfg_zero_star);
    builder.add_causal_inference_enabled(args.causal_inference_enabled);
    builder.add_separate_t5(args.separate_t5);
    builder.add_tea_cache(args.tea_cache);
    builder.add_resolution_dependent_shift(args.resolution_dependent_shift);
    builder.add_speed_up_with_guidance_embed(args.speed_up_with_guidance_embed);
    builder.add_separate_open_clip_g(args.separate_open_clip_g);
    builder.add_separate_clip_l(args.separate_clip_l);
    builder.add_t5_text_encoder(args.t5_text_encoder);
    builder.add_upscaler_scale_factor(args.upscaler_scale_factor);
    builder.add_tiled_diffusion(args.tiled_diffusion);
    builder.add_preserve_original_after_inpaint(args.preserve_original_after_inpaint);
    builder.add_tiled_decoding(args.tiled_decoding);
    builder.add_zero_negative_prompt(args.zero_negative_prompt);
    builder.add_negative_prompt_for_image_prior(args.negative_prompt_for_image_prior);
    builder.add_seed_mode(args.seed_mode);
    builder.add_generated(args.generated);
    builder.add_hires_fix(args.hires_fix);
    builder.add_sampler(args.sampler);
    builder.finish()
  }


  #[inline]
  pub fn lineage(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_LINEAGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn logical_time(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_LOGICAL_TIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn start_width(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_START_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn start_height(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_START_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn seed(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_SEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn steps(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_STEPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn guidance_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_GUIDANCE_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn strength(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_STRENGTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn model(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_MODEL, None)}
  }
  #[inline]
  pub fn tensor_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_TENSOR_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mask_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_MASK_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn wall_clock(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_WALL_CLOCK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn text_edits(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_TEXT_EDITS, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn text_lineage(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_TEXT_LINEAGE, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn batch_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_BATCH_SIZE, Some(1)).unwrap()}
  }
  #[inline]
  pub fn sampler(&self) -> SamplerType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SamplerType>(TensorHistoryNode::VT_SAMPLER, Some(SamplerType::DPMPP2MKarras)).unwrap()}
  }
  #[inline]
  pub fn hires_fix(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_HIRES_FIX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn hires_fix_start_width(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_HIRES_FIX_START_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hires_fix_start_height(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_HIRES_FIX_START_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hires_fix_strength(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_HIRES_FIX_STRENGTH, Some(0.7)).unwrap()}
  }
  #[inline]
  pub fn upscaler(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_UPSCALER, None)}
  }
  #[inline]
  pub fn scale_factor(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_SCALE_FACTOR, Some(1)).unwrap()}
  }
  #[inline]
  pub fn depth_map_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_DEPTH_MAP_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn generated(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_GENERATED, Some(true)).unwrap()}
  }
  #[inline]
  pub fn image_guidance_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_IMAGE_GUIDANCE_SCALE, Some(1.5)).unwrap()}
  }
  #[inline]
  pub fn seed_mode(&self) -> SeedMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SeedMode>(TensorHistoryNode::VT_SEED_MODE, Some(SeedMode::Legacy)).unwrap()}
  }
  #[inline]
  pub fn clip_skip(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_CLIP_SKIP, Some(1)).unwrap()}
  }
  #[inline]
  pub fn controls(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Control<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Control>>>>(TensorHistoryNode::VT_CONTROLS, None)}
  }
  #[inline]
  pub fn scribble_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_SCRIBBLE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pose_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_POSE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn loras(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LoRA<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LoRA>>>>(TensorHistoryNode::VT_LORAS, None)}
  }
  #[inline]
  pub fn color_palette_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_COLOR_PALETTE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mask_blur(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_MASK_BLUR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn custom_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_CUSTOM_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn face_restoration(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_FACE_RESTORATION, None)}
  }
  #[inline]
  pub fn clip_weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_CLIP_WEIGHT, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn negative_prompt_for_image_prior(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_NEGATIVE_PROMPT_FOR_IMAGE_PRIOR, Some(true)).unwrap()}
  }
  #[inline]
  pub fn image_prior_steps(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_IMAGE_PRIOR_STEPS, Some(5)).unwrap()}
  }
  #[inline]
  pub fn data_stored(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_DATA_STORED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn preview_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_PREVIEW_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content_offset_x(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CONTENT_OFFSET_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content_offset_y(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CONTENT_OFFSET_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale_factor_by_120(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_SCALE_FACTOR_BY_120, Some(120)).unwrap()}
  }
  #[inline]
  pub fn refiner_model(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_REFINER_MODEL, None)}
  }
  #[inline]
  pub fn original_image_height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_ORIGINAL_IMAGE_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn original_image_width(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_ORIGINAL_IMAGE_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn crop_top(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CROP_TOP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn crop_left(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CROP_LEFT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_image_height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_TARGET_IMAGE_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_image_width(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_TARGET_IMAGE_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn aesthetic_score(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_AESTHETIC_SCORE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn negative_aesthetic_score(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_NEGATIVE_AESTHETIC_SCORE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn zero_negative_prompt(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_ZERO_NEGATIVE_PROMPT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn refiner_start(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_REFINER_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn negative_original_image_height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_NEGATIVE_ORIGINAL_IMAGE_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn negative_original_image_width(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_NEGATIVE_ORIGINAL_IMAGE_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shuffle_data_stored(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_SHUFFLE_DATA_STORED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fps_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_FPS_ID, Some(5)).unwrap()}
  }
  #[inline]
  pub fn motion_bucket_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_MOTION_BUCKET_ID, Some(127)).unwrap()}
  }
  #[inline]
  pub fn cond_aug(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_COND_AUG, Some(0.02)).unwrap()}
  }
  #[inline]
  pub fn start_frame_cfg(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_START_FRAME_CFG, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn num_frames(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_NUM_FRAMES, Some(14)).unwrap()}
  }
  #[inline]
  pub fn mask_blur_outset(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_MASK_BLUR_OUTSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sharpness(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_SHARPNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn shift(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_SHIFT, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn stage_2_steps(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TensorHistoryNode::VT_STAGE_2_STEPS, Some(10)).unwrap()}
  }
  #[inline]
  pub fn stage_2_cfg(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_STAGE_2_CFG, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn stage_2_shift(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_STAGE_2_SHIFT, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn tiled_decoding(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_TILED_DECODING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn decoding_tile_width(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DECODING_TILE_WIDTH, Some(10)).unwrap()}
  }
  #[inline]
  pub fn decoding_tile_height(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DECODING_TILE_HEIGHT, Some(10)).unwrap()}
  }
  #[inline]
  pub fn decoding_tile_overlap(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DECODING_TILE_OVERLAP, Some(2)).unwrap()}
  }
  #[inline]
  pub fn stochastic_sampling_gamma(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_STOCHASTIC_SAMPLING_GAMMA, Some(0.3)).unwrap()}
  }
  #[inline]
  pub fn preserve_original_after_inpaint(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_PRESERVE_ORIGINAL_AFTER_INPAINT, Some(true)).unwrap()}
  }
  #[inline]
  pub fn tiled_diffusion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_TILED_DIFFUSION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn diffusion_tile_width(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_WIDTH, Some(16)).unwrap()}
  }
  #[inline]
  pub fn diffusion_tile_height(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_HEIGHT, Some(16)).unwrap()}
  }
  #[inline]
  pub fn diffusion_tile_overlap(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_OVERLAP, Some(2)).unwrap()}
  }
  #[inline]
  pub fn upscaler_scale_factor(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TensorHistoryNode::VT_UPSCALER_SCALE_FACTOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn script_session_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TensorHistoryNode::VT_SCRIPT_SESSION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn t5_text_encoder(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_T5_TEXT_ENCODER, Some(true)).unwrap()}
  }
  #[inline]
  pub fn separate_clip_l(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_SEPARATE_CLIP_L, Some(false)).unwrap()}
  }
  #[inline]
  pub fn clip_l_text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_CLIP_L_TEXT, None)}
  }
  #[inline]
  pub fn separate_open_clip_g(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_SEPARATE_OPEN_CLIP_G, Some(false)).unwrap()}
  }
  #[inline]
  pub fn open_clip_g_text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_OPEN_CLIP_G_TEXT, None)}
  }
  #[inline]
  pub fn speed_up_with_guidance_embed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_SPEED_UP_WITH_GUIDANCE_EMBED, Some(true)).unwrap()}
  }
  #[inline]
  pub fn guidance_embed(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_GUIDANCE_EMBED, Some(3.5)).unwrap()}
  }
  #[inline]
  pub fn resolution_dependent_shift(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_RESOLUTION_DEPENDENT_SHIFT, Some(true)).unwrap()}
  }
  #[inline]
  pub fn profile_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TensorHistoryNode::VT_PROFILE_DATA, None)}
  }
  #[inline]
  pub fn tea_cache_start(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_TEA_CACHE_START, Some(5)).unwrap()}
  }
  #[inline]
  pub fn tea_cache_end(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_TEA_CACHE_END, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn tea_cache_threshold(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TensorHistoryNode::VT_TEA_CACHE_THRESHOLD, Some(0.06)).unwrap()}
  }
  #[inline]
  pub fn tea_cache(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_TEA_CACHE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn separate_t5(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_SEPARATE_T5, Some(false)).unwrap()}
  }
  #[inline]
  pub fn t5_text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_T5_TEXT, None)}
  }
  #[inline]
  pub fn tea_cache_max_skip_steps(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_TEA_CACHE_MAX_SKIP_STEPS, Some(3)).unwrap()}
  }
  #[inline]
  pub fn text_prompt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_TEXT_PROMPT, None)}
  }
  #[inline]
  pub fn negative_text_prompt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorHistoryNode::VT_NEGATIVE_TEXT_PROMPT, None)}
  }
  #[inline]
  pub fn clip_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorHistoryNode::VT_CLIP_ID, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn index_in_a_clip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_INDEX_IN_A_CLIP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn causal_inference_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_CAUSAL_INFERENCE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn causal_inference(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CAUSAL_INFERENCE, Some(3)).unwrap()}
  }
  #[inline]
  pub fn causal_inference_pad(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CAUSAL_INFERENCE_PAD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cfg_zero_star(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TensorHistoryNode::VT_CFG_ZERO_STAR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cfg_zero_init_steps(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorHistoryNode::VT_CFG_ZERO_INIT_STEPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn generation_time(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TensorHistoryNode::VT_GENERATION_TIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn reason(&self) -> Reason {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Reason>(TensorHistoryNode::VT_REASON, Some(Reason::Other)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TensorHistoryNode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("lineage", Self::VT_LINEAGE, false)?
     .visit_field::<i64>("logical_time", Self::VT_LOGICAL_TIME, false)?
     .visit_field::<u16>("start_width", Self::VT_START_WIDTH, false)?
     .visit_field::<u16>("start_height", Self::VT_START_HEIGHT, false)?
     .visit_field::<u32>("seed", Self::VT_SEED, false)?
     .visit_field::<u32>("steps", Self::VT_STEPS, false)?
     .visit_field::<f32>("guidance_scale", Self::VT_GUIDANCE_SCALE, false)?
     .visit_field::<f32>("strength", Self::VT_STRENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("model", Self::VT_MODEL, false)?
     .visit_field::<i64>("tensor_id", Self::VT_TENSOR_ID, false)?
     .visit_field::<i64>("mask_id", Self::VT_MASK_ID, false)?
     .visit_field::<i64>("wall_clock", Self::VT_WALL_CLOCK, false)?
     .visit_field::<i64>("text_edits", Self::VT_TEXT_EDITS, false)?
     .visit_field::<i64>("text_lineage", Self::VT_TEXT_LINEAGE, false)?
     .visit_field::<u32>("batch_size", Self::VT_BATCH_SIZE, false)?
     .visit_field::<SamplerType>("sampler", Self::VT_SAMPLER, false)?
     .visit_field::<bool>("hires_fix", Self::VT_HIRES_FIX, false)?
     .visit_field::<u16>("hires_fix_start_width", Self::VT_HIRES_FIX_START_WIDTH, false)?
     .visit_field::<u16>("hires_fix_start_height", Self::VT_HIRES_FIX_START_HEIGHT, false)?
     .visit_field::<f32>("hires_fix_strength", Self::VT_HIRES_FIX_STRENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("upscaler", Self::VT_UPSCALER, false)?
     .visit_field::<u16>("scale_factor", Self::VT_SCALE_FACTOR, false)?
     .visit_field::<i64>("depth_map_id", Self::VT_DEPTH_MAP_ID, false)?
     .visit_field::<bool>("generated", Self::VT_GENERATED, false)?
     .visit_field::<f32>("image_guidance_scale", Self::VT_IMAGE_GUIDANCE_SCALE, false)?
     .visit_field::<SeedMode>("seed_mode", Self::VT_SEED_MODE, false)?
     .visit_field::<u32>("clip_skip", Self::VT_CLIP_SKIP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Control>>>>("controls", Self::VT_CONTROLS, false)?
     .visit_field::<i64>("scribble_id", Self::VT_SCRIBBLE_ID, false)?
     .visit_field::<i64>("pose_id", Self::VT_POSE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LoRA>>>>("loras", Self::VT_LORAS, false)?
     .visit_field::<i64>("color_palette_id", Self::VT_COLOR_PALETTE_ID, false)?
     .visit_field::<f32>("mask_blur", Self::VT_MASK_BLUR, false)?
     .visit_field::<i64>("custom_id", Self::VT_CUSTOM_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("face_restoration", Self::VT_FACE_RESTORATION, false)?
     .visit_field::<f32>("clip_weight", Self::VT_CLIP_WEIGHT, false)?
     .visit_field::<bool>("negative_prompt_for_image_prior", Self::VT_NEGATIVE_PROMPT_FOR_IMAGE_PRIOR, false)?
     .visit_field::<u32>("image_prior_steps", Self::VT_IMAGE_PRIOR_STEPS, false)?
     .visit_field::<i32>("data_stored", Self::VT_DATA_STORED, false)?
     .visit_field::<i64>("preview_id", Self::VT_PREVIEW_ID, false)?
     .visit_field::<i32>("content_offset_x", Self::VT_CONTENT_OFFSET_X, false)?
     .visit_field::<i32>("content_offset_y", Self::VT_CONTENT_OFFSET_Y, false)?
     .visit_field::<i32>("scale_factor_by_120", Self::VT_SCALE_FACTOR_BY_120, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("refiner_model", Self::VT_REFINER_MODEL, false)?
     .visit_field::<u32>("original_image_height", Self::VT_ORIGINAL_IMAGE_HEIGHT, false)?
     .visit_field::<u32>("original_image_width", Self::VT_ORIGINAL_IMAGE_WIDTH, false)?
     .visit_field::<i32>("crop_top", Self::VT_CROP_TOP, false)?
     .visit_field::<i32>("crop_left", Self::VT_CROP_LEFT, false)?
     .visit_field::<u32>("target_image_height", Self::VT_TARGET_IMAGE_HEIGHT, false)?
     .visit_field::<u32>("target_image_width", Self::VT_TARGET_IMAGE_WIDTH, false)?
     .visit_field::<f32>("aesthetic_score", Self::VT_AESTHETIC_SCORE, false)?
     .visit_field::<f32>("negative_aesthetic_score", Self::VT_NEGATIVE_AESTHETIC_SCORE, false)?
     .visit_field::<bool>("zero_negative_prompt", Self::VT_ZERO_NEGATIVE_PROMPT, false)?
     .visit_field::<f32>("refiner_start", Self::VT_REFINER_START, false)?
     .visit_field::<u32>("negative_original_image_height", Self::VT_NEGATIVE_ORIGINAL_IMAGE_HEIGHT, false)?
     .visit_field::<u32>("negative_original_image_width", Self::VT_NEGATIVE_ORIGINAL_IMAGE_WIDTH, false)?
     .visit_field::<i32>("shuffle_data_stored", Self::VT_SHUFFLE_DATA_STORED, false)?
     .visit_field::<u32>("fps_id", Self::VT_FPS_ID, false)?
     .visit_field::<u32>("motion_bucket_id", Self::VT_MOTION_BUCKET_ID, false)?
     .visit_field::<f32>("cond_aug", Self::VT_COND_AUG, false)?
     .visit_field::<f32>("start_frame_cfg", Self::VT_START_FRAME_CFG, false)?
     .visit_field::<u32>("num_frames", Self::VT_NUM_FRAMES, false)?
     .visit_field::<i32>("mask_blur_outset", Self::VT_MASK_BLUR_OUTSET, false)?
     .visit_field::<f32>("sharpness", Self::VT_SHARPNESS, false)?
     .visit_field::<f32>("shift", Self::VT_SHIFT, false)?
     .visit_field::<u32>("stage_2_steps", Self::VT_STAGE_2_STEPS, false)?
     .visit_field::<f32>("stage_2_cfg", Self::VT_STAGE_2_CFG, false)?
     .visit_field::<f32>("stage_2_shift", Self::VT_STAGE_2_SHIFT, false)?
     .visit_field::<bool>("tiled_decoding", Self::VT_TILED_DECODING, false)?
     .visit_field::<u16>("decoding_tile_width", Self::VT_DECODING_TILE_WIDTH, false)?
     .visit_field::<u16>("decoding_tile_height", Self::VT_DECODING_TILE_HEIGHT, false)?
     .visit_field::<u16>("decoding_tile_overlap", Self::VT_DECODING_TILE_OVERLAP, false)?
     .visit_field::<f32>("stochastic_sampling_gamma", Self::VT_STOCHASTIC_SAMPLING_GAMMA, false)?
     .visit_field::<bool>("preserve_original_after_inpaint", Self::VT_PRESERVE_ORIGINAL_AFTER_INPAINT, false)?
     .visit_field::<bool>("tiled_diffusion", Self::VT_TILED_DIFFUSION, false)?
     .visit_field::<u16>("diffusion_tile_width", Self::VT_DIFFUSION_TILE_WIDTH, false)?
     .visit_field::<u16>("diffusion_tile_height", Self::VT_DIFFUSION_TILE_HEIGHT, false)?
     .visit_field::<u16>("diffusion_tile_overlap", Self::VT_DIFFUSION_TILE_OVERLAP, false)?
     .visit_field::<u8>("upscaler_scale_factor", Self::VT_UPSCALER_SCALE_FACTOR, false)?
     .visit_field::<u64>("script_session_id", Self::VT_SCRIPT_SESSION_ID, false)?
     .visit_field::<bool>("t5_text_encoder", Self::VT_T5_TEXT_ENCODER, false)?
     .visit_field::<bool>("separate_clip_l", Self::VT_SEPARATE_CLIP_L, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("clip_l_text", Self::VT_CLIP_L_TEXT, false)?
     .visit_field::<bool>("separate_open_clip_g", Self::VT_SEPARATE_OPEN_CLIP_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("open_clip_g_text", Self::VT_OPEN_CLIP_G_TEXT, false)?
     .visit_field::<bool>("speed_up_with_guidance_embed", Self::VT_SPEED_UP_WITH_GUIDANCE_EMBED, false)?
     .visit_field::<f32>("guidance_embed", Self::VT_GUIDANCE_EMBED, false)?
     .visit_field::<bool>("resolution_dependent_shift", Self::VT_RESOLUTION_DEPENDENT_SHIFT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("profile_data", Self::VT_PROFILE_DATA, false)?
     .visit_field::<i32>("tea_cache_start", Self::VT_TEA_CACHE_START, false)?
     .visit_field::<i32>("tea_cache_end", Self::VT_TEA_CACHE_END, false)?
     .visit_field::<f32>("tea_cache_threshold", Self::VT_TEA_CACHE_THRESHOLD, false)?
     .visit_field::<bool>("tea_cache", Self::VT_TEA_CACHE, false)?
     .visit_field::<bool>("separate_t5", Self::VT_SEPARATE_T5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("t5_text", Self::VT_T5_TEXT, false)?
     .visit_field::<i32>("tea_cache_max_skip_steps", Self::VT_TEA_CACHE_MAX_SKIP_STEPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_prompt", Self::VT_TEXT_PROMPT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("negative_text_prompt", Self::VT_NEGATIVE_TEXT_PROMPT, false)?
     .visit_field::<i64>("clip_id", Self::VT_CLIP_ID, false)?
     .visit_field::<i32>("index_in_a_clip", Self::VT_INDEX_IN_A_CLIP, false)?
     .visit_field::<bool>("causal_inference_enabled", Self::VT_CAUSAL_INFERENCE_ENABLED, false)?
     .visit_field::<i32>("causal_inference", Self::VT_CAUSAL_INFERENCE, false)?
     .visit_field::<i32>("causal_inference_pad", Self::VT_CAUSAL_INFERENCE_PAD, false)?
     .visit_field::<bool>("cfg_zero_star", Self::VT_CFG_ZERO_STAR, false)?
     .visit_field::<i32>("cfg_zero_init_steps", Self::VT_CFG_ZERO_INIT_STEPS, false)?
     .visit_field::<f64>("generation_time", Self::VT_GENERATION_TIME, false)?
     .visit_field::<Reason>("reason", Self::VT_REASON, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorHistoryNodeArgs<'a> {
    pub lineage: i64,
    pub logical_time: i64,
    pub start_width: u16,
    pub start_height: u16,
    pub seed: u32,
    pub steps: u32,
    pub guidance_scale: f32,
    pub strength: f32,
    pub model: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tensor_id: i64,
    pub mask_id: i64,
    pub wall_clock: i64,
    pub text_edits: i64,
    pub text_lineage: i64,
    pub batch_size: u32,
    pub sampler: SamplerType,
    pub hires_fix: bool,
    pub hires_fix_start_width: u16,
    pub hires_fix_start_height: u16,
    pub hires_fix_strength: f32,
    pub upscaler: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scale_factor: u16,
    pub depth_map_id: i64,
    pub generated: bool,
    pub image_guidance_scale: f32,
    pub seed_mode: SeedMode,
    pub clip_skip: u32,
    pub controls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Control<'a>>>>>,
    pub scribble_id: i64,
    pub pose_id: i64,
    pub loras: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LoRA<'a>>>>>,
    pub color_palette_id: i64,
    pub mask_blur: f32,
    pub custom_id: i64,
    pub face_restoration: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clip_weight: f32,
    pub negative_prompt_for_image_prior: bool,
    pub image_prior_steps: u32,
    pub data_stored: i32,
    pub preview_id: i64,
    pub content_offset_x: i32,
    pub content_offset_y: i32,
    pub scale_factor_by_120: i32,
    pub refiner_model: Option<flatbuffers::WIPOffset<&'a str>>,
    pub original_image_height: u32,
    pub original_image_width: u32,
    pub crop_top: i32,
    pub crop_left: i32,
    pub target_image_height: u32,
    pub target_image_width: u32,
    pub aesthetic_score: f32,
    pub negative_aesthetic_score: f32,
    pub zero_negative_prompt: bool,
    pub refiner_start: f32,
    pub negative_original_image_height: u32,
    pub negative_original_image_width: u32,
    pub shuffle_data_stored: i32,
    pub fps_id: u32,
    pub motion_bucket_id: u32,
    pub cond_aug: f32,
    pub start_frame_cfg: f32,
    pub num_frames: u32,
    pub mask_blur_outset: i32,
    pub sharpness: f32,
    pub shift: f32,
    pub stage_2_steps: u32,
    pub stage_2_cfg: f32,
    pub stage_2_shift: f32,
    pub tiled_decoding: bool,
    pub decoding_tile_width: u16,
    pub decoding_tile_height: u16,
    pub decoding_tile_overlap: u16,
    pub stochastic_sampling_gamma: f32,
    pub preserve_original_after_inpaint: bool,
    pub tiled_diffusion: bool,
    pub diffusion_tile_width: u16,
    pub diffusion_tile_height: u16,
    pub diffusion_tile_overlap: u16,
    pub upscaler_scale_factor: u8,
    pub script_session_id: u64,
    pub t5_text_encoder: bool,
    pub separate_clip_l: bool,
    pub clip_l_text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub separate_open_clip_g: bool,
    pub open_clip_g_text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub speed_up_with_guidance_embed: bool,
    pub guidance_embed: f32,
    pub resolution_dependent_shift: bool,
    pub profile_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub tea_cache_start: i32,
    pub tea_cache_end: i32,
    pub tea_cache_threshold: f32,
    pub tea_cache: bool,
    pub separate_t5: bool,
    pub t5_text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tea_cache_max_skip_steps: i32,
    pub text_prompt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub negative_text_prompt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clip_id: i64,
    pub index_in_a_clip: i32,
    pub causal_inference_enabled: bool,
    pub causal_inference: i32,
    pub causal_inference_pad: i32,
    pub cfg_zero_star: bool,
    pub cfg_zero_init_steps: i32,
    pub generation_time: f64,
    pub reason: Reason,
}
impl<'a> Default for TensorHistoryNodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorHistoryNodeArgs {
      lineage: 0,
      logical_time: 0,
      start_width: 0,
      start_height: 0,
      seed: 0,
      steps: 0,
      guidance_scale: 0.0,
      strength: 0.0,
      model: None,
      tensor_id: 0,
      mask_id: 0,
      wall_clock: 0,
      text_edits: -1,
      text_lineage: -1,
      batch_size: 1,
      sampler: SamplerType::DPMPP2MKarras,
      hires_fix: false,
      hires_fix_start_width: 0,
      hires_fix_start_height: 0,
      hires_fix_strength: 0.7,
      upscaler: None,
      scale_factor: 1,
      depth_map_id: 0,
      generated: true,
      image_guidance_scale: 1.5,
      seed_mode: SeedMode::Legacy,
      clip_skip: 1,
      controls: None,
      scribble_id: 0,
      pose_id: 0,
      loras: None,
      color_palette_id: 0,
      mask_blur: 0.0,
      custom_id: 0,
      face_restoration: None,
      clip_weight: 1.0,
      negative_prompt_for_image_prior: true,
      image_prior_steps: 5,
      data_stored: 0,
      preview_id: 0,
      content_offset_x: 0,
      content_offset_y: 0,
      scale_factor_by_120: 120,
      refiner_model: None,
      original_image_height: 0,
      original_image_width: 0,
      crop_top: 0,
      crop_left: 0,
      target_image_height: 0,
      target_image_width: 0,
      aesthetic_score: 0.0,
      negative_aesthetic_score: 0.0,
      zero_negative_prompt: false,
      refiner_start: 0.0,
      negative_original_image_height: 0,
      negative_original_image_width: 0,
      shuffle_data_stored: 0,
      fps_id: 5,
      motion_bucket_id: 127,
      cond_aug: 0.02,
      start_frame_cfg: 1.0,
      num_frames: 14,
      mask_blur_outset: 0,
      sharpness: 0.0,
      shift: 1.0,
      stage_2_steps: 10,
      stage_2_cfg: 1.0,
      stage_2_shift: 1.0,
      tiled_decoding: false,
      decoding_tile_width: 10,
      decoding_tile_height: 10,
      decoding_tile_overlap: 2,
      stochastic_sampling_gamma: 0.3,
      preserve_original_after_inpaint: true,
      tiled_diffusion: false,
      diffusion_tile_width: 16,
      diffusion_tile_height: 16,
      diffusion_tile_overlap: 2,
      upscaler_scale_factor: 0,
      script_session_id: 0,
      t5_text_encoder: true,
      separate_clip_l: false,
      clip_l_text: None,
      separate_open_clip_g: false,
      open_clip_g_text: None,
      speed_up_with_guidance_embed: true,
      guidance_embed: 3.5,
      resolution_dependent_shift: true,
      profile_data: None,
      tea_cache_start: 5,
      tea_cache_end: -1,
      tea_cache_threshold: 0.06,
      tea_cache: false,
      separate_t5: false,
      t5_text: None,
      tea_cache_max_skip_steps: 3,
      text_prompt: None,
      negative_text_prompt: None,
      clip_id: -1,
      index_in_a_clip: 0,
      causal_inference_enabled: false,
      causal_inference: 3,
      causal_inference_pad: 0,
      cfg_zero_star: false,
      cfg_zero_init_steps: 0,
      generation_time: 0.0,
      reason: Reason::Other,
    }
  }
}

pub struct TensorHistoryNodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorHistoryNodeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lineage(&mut self, lineage: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_LINEAGE, lineage, 0);
  }
  #[inline]
  pub fn add_logical_time(&mut self, logical_time: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_LOGICAL_TIME, logical_time, 0);
  }
  #[inline]
  pub fn add_start_width(&mut self, start_width: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_START_WIDTH, start_width, 0);
  }
  #[inline]
  pub fn add_start_height(&mut self, start_height: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_START_HEIGHT, start_height, 0);
  }
  #[inline]
  pub fn add_seed(&mut self, seed: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_SEED, seed, 0);
  }
  #[inline]
  pub fn add_steps(&mut self, steps: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_STEPS, steps, 0);
  }
  #[inline]
  pub fn add_guidance_scale(&mut self, guidance_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_GUIDANCE_SCALE, guidance_scale, 0.0);
  }
  #[inline]
  pub fn add_strength(&mut self, strength: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_STRENGTH, strength, 0.0);
  }
  #[inline]
  pub fn add_model(&mut self, model: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_MODEL, model);
  }
  #[inline]
  pub fn add_tensor_id(&mut self, tensor_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_TENSOR_ID, tensor_id, 0);
  }
  #[inline]
  pub fn add_mask_id(&mut self, mask_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_MASK_ID, mask_id, 0);
  }
  #[inline]
  pub fn add_wall_clock(&mut self, wall_clock: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_WALL_CLOCK, wall_clock, 0);
  }
  #[inline]
  pub fn add_text_edits(&mut self, text_edits: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_TEXT_EDITS, text_edits, -1);
  }
  #[inline]
  pub fn add_text_lineage(&mut self, text_lineage: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_TEXT_LINEAGE, text_lineage, -1);
  }
  #[inline]
  pub fn add_batch_size(&mut self, batch_size: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_BATCH_SIZE, batch_size, 1);
  }
  #[inline]
  pub fn add_sampler(&mut self, sampler: SamplerType) {
    self.fbb_.push_slot::<SamplerType>(TensorHistoryNode::VT_SAMPLER, sampler, SamplerType::DPMPP2MKarras);
  }
  #[inline]
  pub fn add_hires_fix(&mut self, hires_fix: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_HIRES_FIX, hires_fix, false);
  }
  #[inline]
  pub fn add_hires_fix_start_width(&mut self, hires_fix_start_width: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_HIRES_FIX_START_WIDTH, hires_fix_start_width, 0);
  }
  #[inline]
  pub fn add_hires_fix_start_height(&mut self, hires_fix_start_height: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_HIRES_FIX_START_HEIGHT, hires_fix_start_height, 0);
  }
  #[inline]
  pub fn add_hires_fix_strength(&mut self, hires_fix_strength: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_HIRES_FIX_STRENGTH, hires_fix_strength, 0.7);
  }
  #[inline]
  pub fn add_upscaler(&mut self, upscaler: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_UPSCALER, upscaler);
  }
  #[inline]
  pub fn add_scale_factor(&mut self, scale_factor: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_SCALE_FACTOR, scale_factor, 1);
  }
  #[inline]
  pub fn add_depth_map_id(&mut self, depth_map_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_DEPTH_MAP_ID, depth_map_id, 0);
  }
  #[inline]
  pub fn add_generated(&mut self, generated: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_GENERATED, generated, true);
  }
  #[inline]
  pub fn add_image_guidance_scale(&mut self, image_guidance_scale: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_IMAGE_GUIDANCE_SCALE, image_guidance_scale, 1.5);
  }
  #[inline]
  pub fn add_seed_mode(&mut self, seed_mode: SeedMode) {
    self.fbb_.push_slot::<SeedMode>(TensorHistoryNode::VT_SEED_MODE, seed_mode, SeedMode::Legacy);
  }
  #[inline]
  pub fn add_clip_skip(&mut self, clip_skip: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_CLIP_SKIP, clip_skip, 1);
  }
  #[inline]
  pub fn add_controls(&mut self, controls: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Control<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_CONTROLS, controls);
  }
  #[inline]
  pub fn add_scribble_id(&mut self, scribble_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_SCRIBBLE_ID, scribble_id, 0);
  }
  #[inline]
  pub fn add_pose_id(&mut self, pose_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_POSE_ID, pose_id, 0);
  }
  #[inline]
  pub fn add_loras(&mut self, loras: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LoRA<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_LORAS, loras);
  }
  #[inline]
  pub fn add_color_palette_id(&mut self, color_palette_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_COLOR_PALETTE_ID, color_palette_id, 0);
  }
  #[inline]
  pub fn add_mask_blur(&mut self, mask_blur: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_MASK_BLUR, mask_blur, 0.0);
  }
  #[inline]
  pub fn add_custom_id(&mut self, custom_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_CUSTOM_ID, custom_id, 0);
  }
  #[inline]
  pub fn add_face_restoration(&mut self, face_restoration: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_FACE_RESTORATION, face_restoration);
  }
  #[inline]
  pub fn add_clip_weight(&mut self, clip_weight: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_CLIP_WEIGHT, clip_weight, 1.0);
  }
  #[inline]
  pub fn add_negative_prompt_for_image_prior(&mut self, negative_prompt_for_image_prior: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_NEGATIVE_PROMPT_FOR_IMAGE_PRIOR, negative_prompt_for_image_prior, true);
  }
  #[inline]
  pub fn add_image_prior_steps(&mut self, image_prior_steps: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_IMAGE_PRIOR_STEPS, image_prior_steps, 5);
  }
  #[inline]
  pub fn add_data_stored(&mut self, data_stored: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_DATA_STORED, data_stored, 0);
  }
  #[inline]
  pub fn add_preview_id(&mut self, preview_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_PREVIEW_ID, preview_id, 0);
  }
  #[inline]
  pub fn add_content_offset_x(&mut self, content_offset_x: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CONTENT_OFFSET_X, content_offset_x, 0);
  }
  #[inline]
  pub fn add_content_offset_y(&mut self, content_offset_y: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CONTENT_OFFSET_Y, content_offset_y, 0);
  }
  #[inline]
  pub fn add_scale_factor_by_120(&mut self, scale_factor_by_120: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_SCALE_FACTOR_BY_120, scale_factor_by_120, 120);
  }
  #[inline]
  pub fn add_refiner_model(&mut self, refiner_model: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_REFINER_MODEL, refiner_model);
  }
  #[inline]
  pub fn add_original_image_height(&mut self, original_image_height: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_ORIGINAL_IMAGE_HEIGHT, original_image_height, 0);
  }
  #[inline]
  pub fn add_original_image_width(&mut self, original_image_width: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_ORIGINAL_IMAGE_WIDTH, original_image_width, 0);
  }
  #[inline]
  pub fn add_crop_top(&mut self, crop_top: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CROP_TOP, crop_top, 0);
  }
  #[inline]
  pub fn add_crop_left(&mut self, crop_left: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CROP_LEFT, crop_left, 0);
  }
  #[inline]
  pub fn add_target_image_height(&mut self, target_image_height: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_TARGET_IMAGE_HEIGHT, target_image_height, 0);
  }
  #[inline]
  pub fn add_target_image_width(&mut self, target_image_width: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_TARGET_IMAGE_WIDTH, target_image_width, 0);
  }
  #[inline]
  pub fn add_aesthetic_score(&mut self, aesthetic_score: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_AESTHETIC_SCORE, aesthetic_score, 0.0);
  }
  #[inline]
  pub fn add_negative_aesthetic_score(&mut self, negative_aesthetic_score: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_NEGATIVE_AESTHETIC_SCORE, negative_aesthetic_score, 0.0);
  }
  #[inline]
  pub fn add_zero_negative_prompt(&mut self, zero_negative_prompt: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_ZERO_NEGATIVE_PROMPT, zero_negative_prompt, false);
  }
  #[inline]
  pub fn add_refiner_start(&mut self, refiner_start: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_REFINER_START, refiner_start, 0.0);
  }
  #[inline]
  pub fn add_negative_original_image_height(&mut self, negative_original_image_height: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_NEGATIVE_ORIGINAL_IMAGE_HEIGHT, negative_original_image_height, 0);
  }
  #[inline]
  pub fn add_negative_original_image_width(&mut self, negative_original_image_width: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_NEGATIVE_ORIGINAL_IMAGE_WIDTH, negative_original_image_width, 0);
  }
  #[inline]
  pub fn add_shuffle_data_stored(&mut self, shuffle_data_stored: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_SHUFFLE_DATA_STORED, shuffle_data_stored, 0);
  }
  #[inline]
  pub fn add_fps_id(&mut self, fps_id: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_FPS_ID, fps_id, 5);
  }
  #[inline]
  pub fn add_motion_bucket_id(&mut self, motion_bucket_id: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_MOTION_BUCKET_ID, motion_bucket_id, 127);
  }
  #[inline]
  pub fn add_cond_aug(&mut self, cond_aug: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_COND_AUG, cond_aug, 0.02);
  }
  #[inline]
  pub fn add_start_frame_cfg(&mut self, start_frame_cfg: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_START_FRAME_CFG, start_frame_cfg, 1.0);
  }
  #[inline]
  pub fn add_num_frames(&mut self, num_frames: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_NUM_FRAMES, num_frames, 14);
  }
  #[inline]
  pub fn add_mask_blur_outset(&mut self, mask_blur_outset: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_MASK_BLUR_OUTSET, mask_blur_outset, 0);
  }
  #[inline]
  pub fn add_sharpness(&mut self, sharpness: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_SHARPNESS, sharpness, 0.0);
  }
  #[inline]
  pub fn add_shift(&mut self, shift: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_SHIFT, shift, 1.0);
  }
  #[inline]
  pub fn add_stage_2_steps(&mut self, stage_2_steps: u32) {
    self.fbb_.push_slot::<u32>(TensorHistoryNode::VT_STAGE_2_STEPS, stage_2_steps, 10);
  }
  #[inline]
  pub fn add_stage_2_cfg(&mut self, stage_2_cfg: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_STAGE_2_CFG, stage_2_cfg, 1.0);
  }
  #[inline]
  pub fn add_stage_2_shift(&mut self, stage_2_shift: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_STAGE_2_SHIFT, stage_2_shift, 1.0);
  }
  #[inline]
  pub fn add_tiled_decoding(&mut self, tiled_decoding: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_TILED_DECODING, tiled_decoding, false);
  }
  #[inline]
  pub fn add_decoding_tile_width(&mut self, decoding_tile_width: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DECODING_TILE_WIDTH, decoding_tile_width, 10);
  }
  #[inline]
  pub fn add_decoding_tile_height(&mut self, decoding_tile_height: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DECODING_TILE_HEIGHT, decoding_tile_height, 10);
  }
  #[inline]
  pub fn add_decoding_tile_overlap(&mut self, decoding_tile_overlap: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DECODING_TILE_OVERLAP, decoding_tile_overlap, 2);
  }
  #[inline]
  pub fn add_stochastic_sampling_gamma(&mut self, stochastic_sampling_gamma: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_STOCHASTIC_SAMPLING_GAMMA, stochastic_sampling_gamma, 0.3);
  }
  #[inline]
  pub fn add_preserve_original_after_inpaint(&mut self, preserve_original_after_inpaint: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_PRESERVE_ORIGINAL_AFTER_INPAINT, preserve_original_after_inpaint, true);
  }
  #[inline]
  pub fn add_tiled_diffusion(&mut self, tiled_diffusion: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_TILED_DIFFUSION, tiled_diffusion, false);
  }
  #[inline]
  pub fn add_diffusion_tile_width(&mut self, diffusion_tile_width: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_WIDTH, diffusion_tile_width, 16);
  }
  #[inline]
  pub fn add_diffusion_tile_height(&mut self, diffusion_tile_height: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_HEIGHT, diffusion_tile_height, 16);
  }
  #[inline]
  pub fn add_diffusion_tile_overlap(&mut self, diffusion_tile_overlap: u16) {
    self.fbb_.push_slot::<u16>(TensorHistoryNode::VT_DIFFUSION_TILE_OVERLAP, diffusion_tile_overlap, 2);
  }
  #[inline]
  pub fn add_upscaler_scale_factor(&mut self, upscaler_scale_factor: u8) {
    self.fbb_.push_slot::<u8>(TensorHistoryNode::VT_UPSCALER_SCALE_FACTOR, upscaler_scale_factor, 0);
  }
  #[inline]
  pub fn add_script_session_id(&mut self, script_session_id: u64) {
    self.fbb_.push_slot::<u64>(TensorHistoryNode::VT_SCRIPT_SESSION_ID, script_session_id, 0);
  }
  #[inline]
  pub fn add_t5_text_encoder(&mut self, t5_text_encoder: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_T5_TEXT_ENCODER, t5_text_encoder, true);
  }
  #[inline]
  pub fn add_separate_clip_l(&mut self, separate_clip_l: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_SEPARATE_CLIP_L, separate_clip_l, false);
  }
  #[inline]
  pub fn add_clip_l_text(&mut self, clip_l_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_CLIP_L_TEXT, clip_l_text);
  }
  #[inline]
  pub fn add_separate_open_clip_g(&mut self, separate_open_clip_g: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_SEPARATE_OPEN_CLIP_G, separate_open_clip_g, false);
  }
  #[inline]
  pub fn add_open_clip_g_text(&mut self, open_clip_g_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_OPEN_CLIP_G_TEXT, open_clip_g_text);
  }
  #[inline]
  pub fn add_speed_up_with_guidance_embed(&mut self, speed_up_with_guidance_embed: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_SPEED_UP_WITH_GUIDANCE_EMBED, speed_up_with_guidance_embed, true);
  }
  #[inline]
  pub fn add_guidance_embed(&mut self, guidance_embed: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_GUIDANCE_EMBED, guidance_embed, 3.5);
  }
  #[inline]
  pub fn add_resolution_dependent_shift(&mut self, resolution_dependent_shift: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_RESOLUTION_DEPENDENT_SHIFT, resolution_dependent_shift, true);
  }
  #[inline]
  pub fn add_profile_data(&mut self, profile_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_PROFILE_DATA, profile_data);
  }
  #[inline]
  pub fn add_tea_cache_start(&mut self, tea_cache_start: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_TEA_CACHE_START, tea_cache_start, 5);
  }
  #[inline]
  pub fn add_tea_cache_end(&mut self, tea_cache_end: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_TEA_CACHE_END, tea_cache_end, -1);
  }
  #[inline]
  pub fn add_tea_cache_threshold(&mut self, tea_cache_threshold: f32) {
    self.fbb_.push_slot::<f32>(TensorHistoryNode::VT_TEA_CACHE_THRESHOLD, tea_cache_threshold, 0.06);
  }
  #[inline]
  pub fn add_tea_cache(&mut self, tea_cache: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_TEA_CACHE, tea_cache, false);
  }
  #[inline]
  pub fn add_separate_t5(&mut self, separate_t5: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_SEPARATE_T5, separate_t5, false);
  }
  #[inline]
  pub fn add_t5_text(&mut self, t5_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_T5_TEXT, t5_text);
  }
  #[inline]
  pub fn add_tea_cache_max_skip_steps(&mut self, tea_cache_max_skip_steps: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_TEA_CACHE_MAX_SKIP_STEPS, tea_cache_max_skip_steps, 3);
  }
  #[inline]
  pub fn add_text_prompt(&mut self, text_prompt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_TEXT_PROMPT, text_prompt);
  }
  #[inline]
  pub fn add_negative_text_prompt(&mut self, negative_text_prompt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorHistoryNode::VT_NEGATIVE_TEXT_PROMPT, negative_text_prompt);
  }
  #[inline]
  pub fn add_clip_id(&mut self, clip_id: i64) {
    self.fbb_.push_slot::<i64>(TensorHistoryNode::VT_CLIP_ID, clip_id, -1);
  }
  #[inline]
  pub fn add_index_in_a_clip(&mut self, index_in_a_clip: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_INDEX_IN_A_CLIP, index_in_a_clip, 0);
  }
  #[inline]
  pub fn add_causal_inference_enabled(&mut self, causal_inference_enabled: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_CAUSAL_INFERENCE_ENABLED, causal_inference_enabled, false);
  }
  #[inline]
  pub fn add_causal_inference(&mut self, causal_inference: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CAUSAL_INFERENCE, causal_inference, 3);
  }
  #[inline]
  pub fn add_causal_inference_pad(&mut self, causal_inference_pad: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CAUSAL_INFERENCE_PAD, causal_inference_pad, 0);
  }
  #[inline]
  pub fn add_cfg_zero_star(&mut self, cfg_zero_star: bool) {
    self.fbb_.push_slot::<bool>(TensorHistoryNode::VT_CFG_ZERO_STAR, cfg_zero_star, false);
  }
  #[inline]
  pub fn add_cfg_zero_init_steps(&mut self, cfg_zero_init_steps: i32) {
    self.fbb_.push_slot::<i32>(TensorHistoryNode::VT_CFG_ZERO_INIT_STEPS, cfg_zero_init_steps, 0);
  }
  #[inline]
  pub fn add_generation_time(&mut self, generation_time: f64) {
    self.fbb_.push_slot::<f64>(TensorHistoryNode::VT_GENERATION_TIME, generation_time, 0.0);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: Reason) {
    self.fbb_.push_slot::<Reason>(TensorHistoryNode::VT_REASON, reason, Reason::Other);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorHistoryNodeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorHistoryNodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorHistoryNode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorHistoryNode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorHistoryNode");
      ds.field("lineage", &self.lineage());
      ds.field("logical_time", &self.logical_time());
      ds.field("start_width", &self.start_width());
      ds.field("start_height", &self.start_height());
      ds.field("seed", &self.seed());
      ds.field("steps", &self.steps());
      ds.field("guidance_scale", &self.guidance_scale());
      ds.field("strength", &self.strength());
      ds.field("model", &self.model());
      ds.field("tensor_id", &self.tensor_id());
      ds.field("mask_id", &self.mask_id());
      ds.field("wall_clock", &self.wall_clock());
      ds.field("text_edits", &self.text_edits());
      ds.field("text_lineage", &self.text_lineage());
      ds.field("batch_size", &self.batch_size());
      ds.field("sampler", &self.sampler());
      ds.field("hires_fix", &self.hires_fix());
      ds.field("hires_fix_start_width", &self.hires_fix_start_width());
      ds.field("hires_fix_start_height", &self.hires_fix_start_height());
      ds.field("hires_fix_strength", &self.hires_fix_strength());
      ds.field("upscaler", &self.upscaler());
      ds.field("scale_factor", &self.scale_factor());
      ds.field("depth_map_id", &self.depth_map_id());
      ds.field("generated", &self.generated());
      ds.field("image_guidance_scale", &self.image_guidance_scale());
      ds.field("seed_mode", &self.seed_mode());
      ds.field("clip_skip", &self.clip_skip());
      ds.field("controls", &self.controls());
      ds.field("scribble_id", &self.scribble_id());
      ds.field("pose_id", &self.pose_id());
      ds.field("loras", &self.loras());
      ds.field("color_palette_id", &self.color_palette_id());
      ds.field("mask_blur", &self.mask_blur());
      ds.field("custom_id", &self.custom_id());
      ds.field("face_restoration", &self.face_restoration());
      ds.field("clip_weight", &self.clip_weight());
      ds.field("negative_prompt_for_image_prior", &self.negative_prompt_for_image_prior());
      ds.field("image_prior_steps", &self.image_prior_steps());
      ds.field("data_stored", &self.data_stored());
      ds.field("preview_id", &self.preview_id());
      ds.field("content_offset_x", &self.content_offset_x());
      ds.field("content_offset_y", &self.content_offset_y());
      ds.field("scale_factor_by_120", &self.scale_factor_by_120());
      ds.field("refiner_model", &self.refiner_model());
      ds.field("original_image_height", &self.original_image_height());
      ds.field("original_image_width", &self.original_image_width());
      ds.field("crop_top", &self.crop_top());
      ds.field("crop_left", &self.crop_left());
      ds.field("target_image_height", &self.target_image_height());
      ds.field("target_image_width", &self.target_image_width());
      ds.field("aesthetic_score", &self.aesthetic_score());
      ds.field("negative_aesthetic_score", &self.negative_aesthetic_score());
      ds.field("zero_negative_prompt", &self.zero_negative_prompt());
      ds.field("refiner_start", &self.refiner_start());
      ds.field("negative_original_image_height", &self.negative_original_image_height());
      ds.field("negative_original_image_width", &self.negative_original_image_width());
      ds.field("shuffle_data_stored", &self.shuffle_data_stored());
      ds.field("fps_id", &self.fps_id());
      ds.field("motion_bucket_id", &self.motion_bucket_id());
      ds.field("cond_aug", &self.cond_aug());
      ds.field("start_frame_cfg", &self.start_frame_cfg());
      ds.field("num_frames", &self.num_frames());
      ds.field("mask_blur_outset", &self.mask_blur_outset());
      ds.field("sharpness", &self.sharpness());
      ds.field("shift", &self.shift());
      ds.field("stage_2_steps", &self.stage_2_steps());
      ds.field("stage_2_cfg", &self.stage_2_cfg());
      ds.field("stage_2_shift", &self.stage_2_shift());
      ds.field("tiled_decoding", &self.tiled_decoding());
      ds.field("decoding_tile_width", &self.decoding_tile_width());
      ds.field("decoding_tile_height", &self.decoding_tile_height());
      ds.field("decoding_tile_overlap", &self.decoding_tile_overlap());
      ds.field("stochastic_sampling_gamma", &self.stochastic_sampling_gamma());
      ds.field("preserve_original_after_inpaint", &self.preserve_original_after_inpaint());
      ds.field("tiled_diffusion", &self.tiled_diffusion());
      ds.field("diffusion_tile_width", &self.diffusion_tile_width());
      ds.field("diffusion_tile_height", &self.diffusion_tile_height());
      ds.field("diffusion_tile_overlap", &self.diffusion_tile_overlap());
      ds.field("upscaler_scale_factor", &self.upscaler_scale_factor());
      ds.field("script_session_id", &self.script_session_id());
      ds.field("t5_text_encoder", &self.t5_text_encoder());
      ds.field("separate_clip_l", &self.separate_clip_l());
      ds.field("clip_l_text", &self.clip_l_text());
      ds.field("separate_open_clip_g", &self.separate_open_clip_g());
      ds.field("open_clip_g_text", &self.open_clip_g_text());
      ds.field("speed_up_with_guidance_embed", &self.speed_up_with_guidance_embed());
      ds.field("guidance_embed", &self.guidance_embed());
      ds.field("resolution_dependent_shift", &self.resolution_dependent_shift());
      ds.field("profile_data", &self.profile_data());
      ds.field("tea_cache_start", &self.tea_cache_start());
      ds.field("tea_cache_end", &self.tea_cache_end());
      ds.field("tea_cache_threshold", &self.tea_cache_threshold());
      ds.field("tea_cache", &self.tea_cache());
      ds.field("separate_t5", &self.separate_t5());
      ds.field("t5_text", &self.t5_text());
      ds.field("tea_cache_max_skip_steps", &self.tea_cache_max_skip_steps());
      ds.field("text_prompt", &self.text_prompt());
      ds.field("negative_text_prompt", &self.negative_text_prompt());
      ds.field("clip_id", &self.clip_id());
      ds.field("index_in_a_clip", &self.index_in_a_clip());
      ds.field("causal_inference_enabled", &self.causal_inference_enabled());
      ds.field("causal_inference", &self.causal_inference());
      ds.field("causal_inference_pad", &self.causal_inference_pad());
      ds.field("cfg_zero_star", &self.cfg_zero_star());
      ds.field("cfg_zero_init_steps", &self.cfg_zero_init_steps());
      ds.field("generation_time", &self.generation_time());
      ds.field("reason", &self.reason());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TensorHistoryNode`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_history_node_unchecked`.
pub fn root_as_tensor_history_node(buf: &[u8]) -> Result<TensorHistoryNode, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TensorHistoryNode>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TensorHistoryNode` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_tensor_history_node_unchecked`.
pub fn size_prefixed_root_as_tensor_history_node(buf: &[u8]) -> Result<TensorHistoryNode, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TensorHistoryNode>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TensorHistoryNode` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_history_node_unchecked`.
pub fn root_as_tensor_history_node_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TensorHistoryNode<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TensorHistoryNode<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TensorHistoryNode` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_history_node_unchecked`.
pub fn size_prefixed_root_as_tensor_history_node_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TensorHistoryNode<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TensorHistoryNode<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TensorHistoryNode and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TensorHistoryNode`.
pub unsafe fn root_as_tensor_history_node_unchecked(buf: &[u8]) -> TensorHistoryNode {
  flatbuffers::root_unchecked::<TensorHistoryNode>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TensorHistoryNode and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TensorHistoryNode`.
pub unsafe fn size_prefixed_root_as_tensor_history_node_unchecked(buf: &[u8]) -> TensorHistoryNode {
  flatbuffers::size_prefixed_root_unchecked::<TensorHistoryNode>(buf)
}
#[inline]
pub fn finish_tensor_history_node_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TensorHistoryNode<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_tensor_history_node_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TensorHistoryNode<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
