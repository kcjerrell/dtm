// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum TensorDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorData<'a> {
  type Inner = TensorData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TensorData<'a> {
  pub const VT_LINEAGE: flatbuffers::VOffsetT = 4;
  pub const VT_LOGICAL_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_X: flatbuffers::VOffsetT = 10;
  pub const VT_Y: flatbuffers::VOffsetT = 12;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 14;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 16;
  pub const VT_SCALE_FACTOR_BY_120: flatbuffers::VOffsetT = 18;
  pub const VT_TENSOR_ID: flatbuffers::VOffsetT = 20;
  pub const VT_MASK_ID: flatbuffers::VOffsetT = 22;
  pub const VT_DEPTH_MAP_ID: flatbuffers::VOffsetT = 24;
  pub const VT_SCRIBBLE_ID: flatbuffers::VOffsetT = 26;
  pub const VT_POSE_ID: flatbuffers::VOffsetT = 28;
  pub const VT_COLOR_PALETTE_ID: flatbuffers::VOffsetT = 30;
  pub const VT_CUSTOM_ID: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TensorDataArgs
  ) -> flatbuffers::WIPOffset<TensorData<'bldr>> {
    let mut builder = TensorDataBuilder::new(_fbb);
    builder.add_custom_id(args.custom_id);
    builder.add_color_palette_id(args.color_palette_id);
    builder.add_pose_id(args.pose_id);
    builder.add_scribble_id(args.scribble_id);
    builder.add_depth_map_id(args.depth_map_id);
    builder.add_mask_id(args.mask_id);
    builder.add_tensor_id(args.tensor_id);
    builder.add_index(args.index);
    builder.add_logical_time(args.logical_time);
    builder.add_lineage(args.lineage);
    builder.add_scale_factor_by_120(args.scale_factor_by_120);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn lineage(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_LINEAGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn logical_time(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_LOGICAL_TIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorData::VT_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorData::VT_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorData::VT_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorData::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale_factor_by_120(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TensorData::VT_SCALE_FACTOR_BY_120, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tensor_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_TENSOR_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn mask_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_MASK_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn depth_map_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_DEPTH_MAP_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scribble_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_SCRIBBLE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pose_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_POSE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn color_palette_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_COLOR_PALETTE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn custom_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TensorData::VT_CUSTOM_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TensorData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("lineage", Self::VT_LINEAGE, false)?
     .visit_field::<i64>("logical_time", Self::VT_LOGICAL_TIME, false)?
     .visit_field::<i64>("index", Self::VT_INDEX, false)?
     .visit_field::<i32>("x", Self::VT_X, false)?
     .visit_field::<i32>("y", Self::VT_Y, false)?
     .visit_field::<i32>("width", Self::VT_WIDTH, false)?
     .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<i32>("scale_factor_by_120", Self::VT_SCALE_FACTOR_BY_120, false)?
     .visit_field::<i64>("tensor_id", Self::VT_TENSOR_ID, false)?
     .visit_field::<i64>("mask_id", Self::VT_MASK_ID, false)?
     .visit_field::<i64>("depth_map_id", Self::VT_DEPTH_MAP_ID, false)?
     .visit_field::<i64>("scribble_id", Self::VT_SCRIBBLE_ID, false)?
     .visit_field::<i64>("pose_id", Self::VT_POSE_ID, false)?
     .visit_field::<i64>("color_palette_id", Self::VT_COLOR_PALETTE_ID, false)?
     .visit_field::<i64>("custom_id", Self::VT_CUSTOM_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorDataArgs {
    pub lineage: i64,
    pub logical_time: i64,
    pub index: i64,
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    pub scale_factor_by_120: i32,
    pub tensor_id: i64,
    pub mask_id: i64,
    pub depth_map_id: i64,
    pub scribble_id: i64,
    pub pose_id: i64,
    pub color_palette_id: i64,
    pub custom_id: i64,
}
impl<'a> Default for TensorDataArgs {
  #[inline]
  fn default() -> Self {
    TensorDataArgs {
      lineage: 0,
      logical_time: 0,
      index: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      scale_factor_by_120: 0,
      tensor_id: 0,
      mask_id: 0,
      depth_map_id: 0,
      scribble_id: 0,
      pose_id: 0,
      color_palette_id: 0,
      custom_id: 0,
    }
  }
}

pub struct TensorDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TensorDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lineage(&mut self, lineage: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_LINEAGE, lineage, 0);
  }
  #[inline]
  pub fn add_logical_time(&mut self, logical_time: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_LOGICAL_TIME, logical_time, 0);
  }
  #[inline]
  pub fn add_index(&mut self, index: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_x(&mut self, x: i32) {
    self.fbb_.push_slot::<i32>(TensorData::VT_X, x, 0);
  }
  #[inline]
  pub fn add_y(&mut self, y: i32) {
    self.fbb_.push_slot::<i32>(TensorData::VT_Y, y, 0);
  }
  #[inline]
  pub fn add_width(&mut self, width: i32) {
    self.fbb_.push_slot::<i32>(TensorData::VT_WIDTH, width, 0);
  }
  #[inline]
  pub fn add_height(&mut self, height: i32) {
    self.fbb_.push_slot::<i32>(TensorData::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_scale_factor_by_120(&mut self, scale_factor_by_120: i32) {
    self.fbb_.push_slot::<i32>(TensorData::VT_SCALE_FACTOR_BY_120, scale_factor_by_120, 0);
  }
  #[inline]
  pub fn add_tensor_id(&mut self, tensor_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_TENSOR_ID, tensor_id, 0);
  }
  #[inline]
  pub fn add_mask_id(&mut self, mask_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_MASK_ID, mask_id, 0);
  }
  #[inline]
  pub fn add_depth_map_id(&mut self, depth_map_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_DEPTH_MAP_ID, depth_map_id, 0);
  }
  #[inline]
  pub fn add_scribble_id(&mut self, scribble_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_SCRIBBLE_ID, scribble_id, 0);
  }
  #[inline]
  pub fn add_pose_id(&mut self, pose_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_POSE_ID, pose_id, 0);
  }
  #[inline]
  pub fn add_color_palette_id(&mut self, color_palette_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_COLOR_PALETTE_ID, color_palette_id, 0);
  }
  #[inline]
  pub fn add_custom_id(&mut self, custom_id: i64) {
    self.fbb_.push_slot::<i64>(TensorData::VT_CUSTOM_ID, custom_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TensorDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TensorDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorData");
      ds.field("lineage", &self.lineage());
      ds.field("logical_time", &self.logical_time());
      ds.field("index", &self.index());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("scale_factor_by_120", &self.scale_factor_by_120());
      ds.field("tensor_id", &self.tensor_id());
      ds.field("mask_id", &self.mask_id());
      ds.field("depth_map_id", &self.depth_map_id());
      ds.field("scribble_id", &self.scribble_id());
      ds.field("pose_id", &self.pose_id());
      ds.field("color_palette_id", &self.color_palette_id());
      ds.field("custom_id", &self.custom_id());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TensorData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_data_unchecked`.
pub fn root_as_tensor_data(buf: &[u8]) -> Result<TensorData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TensorData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TensorData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_tensor_data_unchecked`.
pub fn size_prefixed_root_as_tensor_data(buf: &[u8]) -> Result<TensorData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TensorData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TensorData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_data_unchecked`.
pub fn root_as_tensor_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TensorData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TensorData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TensorData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_tensor_data_unchecked`.
pub fn size_prefixed_root_as_tensor_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TensorData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TensorData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TensorData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TensorData`.
pub unsafe fn root_as_tensor_data_unchecked(buf: &[u8]) -> TensorData {
  unsafe { flatbuffers::root_unchecked::<TensorData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TensorData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TensorData`.
pub unsafe fn size_prefixed_root_as_tensor_data_unchecked(buf: &[u8]) -> TensorData {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<TensorData>(buf) }
}
#[inline]
pub fn finish_tensor_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TensorData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_tensor_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TensorData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
