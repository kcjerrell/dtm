// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ControlOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Control<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Control<'a> {
  type Inner = Control<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Control<'a> {
  pub const VT_FILE: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_GUIDANCE_START: flatbuffers::VOffsetT = 8;
  pub const VT_GUIDANCE_END: flatbuffers::VOffsetT = 10;
  pub const VT_NO_PROMPT: flatbuffers::VOffsetT = 12;
  pub const VT_GLOBAL_AVERAGE_POOLING: flatbuffers::VOffsetT = 14;
  pub const VT_DOWN_SAMPLING_RATE: flatbuffers::VOffsetT = 16;
  pub const VT_CONTROL_MODE: flatbuffers::VOffsetT = 18;
  pub const VT_TARGET_BLOCKS: flatbuffers::VOffsetT = 20;
  pub const VT_INPUT_OVERRIDE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Control { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ControlArgs<'args>
  ) -> flatbuffers::WIPOffset<Control<'bldr>> {
    let mut builder = ControlBuilder::new(_fbb);
    if let Some(x) = args.target_blocks { builder.add_target_blocks(x); }
    builder.add_down_sampling_rate(args.down_sampling_rate);
    builder.add_guidance_end(args.guidance_end);
    builder.add_guidance_start(args.guidance_start);
    builder.add_weight(args.weight);
    if let Some(x) = args.file { builder.add_file(x); }
    builder.add_input_override(args.input_override);
    builder.add_control_mode(args.control_mode);
    builder.add_global_average_pooling(args.global_average_pooling);
    builder.add_no_prompt(args.no_prompt);
    builder.finish()
  }


  #[inline]
  pub fn file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Control::VT_FILE, None)}
  }
  #[inline]
  pub fn weight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_WEIGHT, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn guidance_start(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_GUIDANCE_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn guidance_end(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_GUIDANCE_END, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn no_prompt(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Control::VT_NO_PROMPT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn global_average_pooling(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Control::VT_GLOBAL_AVERAGE_POOLING, Some(true)).unwrap()}
  }
  #[inline]
  pub fn down_sampling_rate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Control::VT_DOWN_SAMPLING_RATE, Some(1.0)).unwrap()}
  }
  #[inline]
  pub fn control_mode(&self) -> ControlMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ControlMode>(Control::VT_CONTROL_MODE, Some(ControlMode::Balanced)).unwrap()}
  }
  #[inline]
  pub fn target_blocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Control::VT_TARGET_BLOCKS, None)}
  }
  #[inline]
  pub fn input_override(&self) -> ControlInputType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ControlInputType>(Control::VT_INPUT_OVERRIDE, Some(ControlInputType::Unspecified)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Control<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file", Self::VT_FILE, false)?
     .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<f32>("guidance_start", Self::VT_GUIDANCE_START, false)?
     .visit_field::<f32>("guidance_end", Self::VT_GUIDANCE_END, false)?
     .visit_field::<bool>("no_prompt", Self::VT_NO_PROMPT, false)?
     .visit_field::<bool>("global_average_pooling", Self::VT_GLOBAL_AVERAGE_POOLING, false)?
     .visit_field::<f32>("down_sampling_rate", Self::VT_DOWN_SAMPLING_RATE, false)?
     .visit_field::<ControlMode>("control_mode", Self::VT_CONTROL_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("target_blocks", Self::VT_TARGET_BLOCKS, false)?
     .visit_field::<ControlInputType>("input_override", Self::VT_INPUT_OVERRIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct ControlArgs<'a> {
    pub file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub guidance_start: f32,
    pub guidance_end: f32,
    pub no_prompt: bool,
    pub global_average_pooling: bool,
    pub down_sampling_rate: f32,
    pub control_mode: ControlMode,
    pub target_blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub input_override: ControlInputType,
}
impl<'a> Default for ControlArgs<'a> {
  #[inline]
  fn default() -> Self {
    ControlArgs {
      file: None,
      weight: 1.0,
      guidance_start: 0.0,
      guidance_end: 1.0,
      no_prompt: false,
      global_average_pooling: true,
      down_sampling_rate: 1.0,
      control_mode: ControlMode::Balanced,
      target_blocks: None,
      input_override: ControlInputType::Unspecified,
    }
  }
}

pub struct ControlBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ControlBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_file(&mut self, file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Control::VT_FILE, file);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_WEIGHT, weight, 1.0);
  }
  #[inline]
  pub fn add_guidance_start(&mut self, guidance_start: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_GUIDANCE_START, guidance_start, 0.0);
  }
  #[inline]
  pub fn add_guidance_end(&mut self, guidance_end: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_GUIDANCE_END, guidance_end, 1.0);
  }
  #[inline]
  pub fn add_no_prompt(&mut self, no_prompt: bool) {
    self.fbb_.push_slot::<bool>(Control::VT_NO_PROMPT, no_prompt, false);
  }
  #[inline]
  pub fn add_global_average_pooling(&mut self, global_average_pooling: bool) {
    self.fbb_.push_slot::<bool>(Control::VT_GLOBAL_AVERAGE_POOLING, global_average_pooling, true);
  }
  #[inline]
  pub fn add_down_sampling_rate(&mut self, down_sampling_rate: f32) {
    self.fbb_.push_slot::<f32>(Control::VT_DOWN_SAMPLING_RATE, down_sampling_rate, 1.0);
  }
  #[inline]
  pub fn add_control_mode(&mut self, control_mode: ControlMode) {
    self.fbb_.push_slot::<ControlMode>(Control::VT_CONTROL_MODE, control_mode, ControlMode::Balanced);
  }
  #[inline]
  pub fn add_target_blocks(&mut self, target_blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Control::VT_TARGET_BLOCKS, target_blocks);
  }
  #[inline]
  pub fn add_input_override(&mut self, input_override: ControlInputType) {
    self.fbb_.push_slot::<ControlInputType>(Control::VT_INPUT_OVERRIDE, input_override, ControlInputType::Unspecified);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ControlBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ControlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Control<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Control<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Control");
      ds.field("file", &self.file());
      ds.field("weight", &self.weight());
      ds.field("guidance_start", &self.guidance_start());
      ds.field("guidance_end", &self.guidance_end());
      ds.field("no_prompt", &self.no_prompt());
      ds.field("global_average_pooling", &self.global_average_pooling());
      ds.field("down_sampling_rate", &self.down_sampling_rate());
      ds.field("control_mode", &self.control_mode());
      ds.field("target_blocks", &self.target_blocks());
      ds.field("input_override", &self.input_override());
      ds.finish()
  }
}
